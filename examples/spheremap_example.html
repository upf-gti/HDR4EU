<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />

<title>sphere map viewer</title>
<link rel="stylesheet" href="css/bootstrap.min.css">
	<style type='text/css'>
		html, body { width: 100%; height: 100%; margin: 0; padding: 0 }
	</style>
	<script type="text/javascript" src="js/gl-matrix-min.js"></script>
	<script type="text/javascript" src="js/litegl-mod.js"></script>
  <script type="text/javascript" src="js/litescene.js"></script>
  <script type="text/javascript" src="js/dat.gui.min.js"></script>
	<script type="text/javascript" src="js/tinyexr.js"></script>
	<script type="text/javascript" src="js/rendeer.js"></script>
	<script type="text/javascript" src="js/utils.js"></script>
	<script type="text/javascript" src="js/parse.js"></script>
	<script type="text/javascript">

        function init()
        {
            //create a scene
            scene = new RD.Scene();

            //create the rendering context
            var context = GL.create({width: window.innerWidth, height:window.innerHeight});

            renderer = new RD.Renderer(context, {
                shaders_file: "data/shaders.glsl",
                autoload_assets: true
            });

            document.body.appendChild(renderer.canvas); //attach

						document.querySelector(".container").onmouseleave = function(e){ e.target.style.opacity = 0.2 }
						document.querySelector(".container").onmouseenter = function(e){ e.target.style.opacity = 1.0 }

						document.body.ondragover = function(){ return false;}
						document.body.ondragend = function(){ return false;}
						document.body.ondrop = function( e )
						{
							e.preventDefault();

							var file = e.dataTransfer.files[0],
								name = file.name;

                            //prepare reader
                            var reader = new FileReader();
                            reader.onload = function (event) {
                                //console.log(event.target);
                                var data = event.target.result;
                                do_things( data, name.includes("cubemap") );
                            };

                            //read data
                            reader.readAsArrayBuffer(file);
                            return false;
						}

            //create camera
            camera = new RD.Camera();
            camera.perspective( 45, gl.canvas.width / gl.canvas.height, 0.01, 1000000 );
           	camera.lookAt( [0,0,750],[0,0,0],[0,1,0] );

						skybox = new RD.SceneNode({
		            mesh: "cube",
								shader: "sphereMap"
		        });

						skybox.flags.depth_test = false;
		        skybox.flags.flip_normals = true;
						skybox.flags.visible = false;
		        skybox.render_priority = RD.PRIORITY_BACKGROUND;
		        scene.root.addChild( skybox );

            //create a cube in the scene
            box = new RD.SceneNode();
            box.position = [0,0,0];
            box.color = [1,1,1,1];
            box.mesh = "plane";
            box.scale([100,100,100]);
            box.flags.two_sided = true;
            box.flags.visible = false;
						scene.root.addChild(box);

						renderer._uniforms.exposure = 5.5;
						renderer._uniforms.brightMax = 18.0;

						var params_gui = {
										exposure: renderer._uniforms.exposure,
						};

						var gui = new dat.GUI();
						gui.add( params_gui, 'exposure', 0.1, 20 );
						gui.open();

            //global settings
            var bg_color = vec4.fromValues(0.2,0.3,0.4,1);

            //main render loop
            var last = now = getTime();

            function ondraw() {

								// get gui params_gui
								renderer._uniforms.exposure = params_gui.exposure;

                last = now;
                now = getTime();
                var dt = (now - last) * 0.001;
                renderer.clear(bg_color);

								skybox.position = camera.position;
                renderer.render(scene, camera);
            }

						renderer.context.ondraw = ondraw;
						renderer.context.onupdate = function(dt){
							scene.update(dt);
						}
						renderer.context.animate();

            //input
            renderer.context.captureKeys(true);
						renderer.context.onkeydown = function(e)
						{
							if(e.keyCode === 82)
								renderer.loadShaders( "data/shaders.glsl" );
						}

						renderer.context.captureMouse(true);
            renderer.context.onmousemove = function(e)
            {
                if(e.dragging){
									camera.orbit(-e.deltax * 0.01, RD.UP);
                  camera.orbit(-e.deltay * 0.01, camera._right);
								}
            }
						renderer.context.onmousewheel = function(e)
		        {
		            if(!e.wheel)
		                return;
		            camera.position = vec3.scale( camera.position, camera.position, e.wheel < 0 ? 1.05 : 0.95 );
		        }
        }

				function do_things( arraybuffer, is_cubemap )
        {
            var texData = parseEXRImage(arraybuffer);
           	console.log(texData);

            var width = texData.width;
            var height = texData.height;

						// tiny exr library adds a channel extra we want to remove
						var fakeNchannels = texData.data.length / (width * height);
						var pixelData, pixelFormat;

						// remove extra channel
						var oldSize = texData.data.length,
								newSize = oldSize * (3/4);
						var data = new Float32Array(newSize);

						var it = 0;

						for(var i = 0; i < oldSize; i += 4){
								data[it] = texData.data[i];
								data[it+1] = texData.data[i+1];
								data[it+2] = texData.data[i+2];
								it+=3;
						}

						if(texData.numChannels === 3)
            {
							pixelFormat = gl.RGB;
							if(fakeNchannels === 3)
                pixelData = texData.data;
							else
                pixelData = data;
            }
            else(texData.numChannels === 4)
            {
                pixelFormat = gl.RGB;
                pixelData = data;
            }

						console.log('Pixel data length:', pixelData.length);
						generateTexture(width, height, pixelFormat, pixelData, texData, is_cubemap);
        }

				function generateTexture(width, height, pixelFormat, pixelData, texData)
				{
						// basic texture
						var texture = new GL.Texture( width, height, { format: pixelFormat, type: gl.FLOAT, pixel_data: pixelData });

						texture.wrapS = texData.wrapS ? texData.wrapS : gl.CLAMP_TO_EDGE;
						texture.wrapT = texData.wrapT ? texData.wrapT : gl.CLAMP_TO_EDGE;
						texture.magFilter = texData.magFilter ? texData.magFilter : gl.LINEAR;
						texture.minFilter = texData.minFilter ? texData.minFilter : gl.LINEAR_MIPMAP_LINEAR;

						renderer.textures["exr"] = texture;
						skybox.texture = "exr";
						skybox.flags.visible = true;
				}

            function readFile(name)
            {
                var url = "../textures/" + name;

                var xhr = new XMLHttpRequest();
                xhr.open( "GET", url, true );
                xhr.responseType = "arraybuffer";

                xhr.onload = function( e ) {
                    do_things(this.response, url.includes( "cubemap" ));
                };

                xhr.send();
            }

	</script>
</head>
<body>
	<div class="container" style="position: absolute !important; left: calc(50% - 200px);border: 3px white dotted; height: 250px; width: 400px; top: 30vh; text-align: center;">
		<h2 style="color: white; margin-top: 100px;">DRAG FILE OR</h2>
        <button class="btn btn-primary" onclick="readFile('stpeters_clamped_spheremap.exr')">Example 1</button>
        <button class="btn btn-primary" onclick="readFile('water_spheremap.exr')">Example 2</button>
	</div>
</body>
    <script>init();</script>
</html>
